In section \ref{improv: search algorithms} on different search algorithms we already did a short discussion on the completeness of different algorithms. The current section will start with a short recap of our findings, expand them to other planners and will then do an expanded discussion that takes factors like loop detection and restarts into account. \\
Before we dive into the more detailed discussion we want to note that we have seen in section \ref{prelim: tohtn complexity} that there is an upper bound to task network depth where, if a plan exists at all, it can be found before that depth. By limiting our planning to task network expansions with lower depth, we can trivially achieve completeness. This is however of little practical use as this depth bound is exponential in the problem size. As a result, we can expect to run out of memory before hitting this bound. For this reason we do not make use of this bound and as far as we know no other planner does. We will now resume a more practical discussion of planner completeness.\\ 
As previously noted, we can split our search algorithms into three main groups:
\begin{itemize}
	\item Algorithms that are complete (BFS, A-star like search)
	\item Algorithms with a chance but no guarantee to find a plan (DFS)
	\item Algorithms which for some domains will never find a plan (heuristic DFS with pathological cases)
\end{itemize}
\paragraph{Completeness in other planners}
So far we have only classified the different search algorithms present in CrowdHTN. For now we will take a look at other planners, starting with translation-based planners totSAT (\cite{behnke2018totsat}), Tree-REX (\cite{schreiber2019tree}) and Lilotane (\cite{schreiber2021lilotane}). As we have noted in the discussion on planning algorithms in section \ref{prelim: translation based planners}, all three of these planners are based on SAT. Additionally, they all explore the set of potential expansions of the task hierarchy in a layer-by-layer fashion, leading to a BFS-like characteristic in their behavior. As a result, these planners are complete. \\
In contrast to this, we have the space of search-based planners, starting with HyperTensioN \cite{magnaguagno2020hypertension}. For HyperTensioN, the authors themselves note that their inbuilt loop detection mechanism suffers from false positives with no mechanism to mitigate them \cite{magnaguagno2020hypertension}. It follows that their planner is not complete. If we disabled the loop detection in HyperTensioN we would be left with a planner performing DFS, which would put it in the category of planners which are not complete but still have a chance to solve any instance. \\
PANDA on the other hand is a planner based on heuristic progression search that offers a number of configuration options for both search and loop detection. Regarding search, PANDA offers both a pure heuristic DFS and a weighted A* search taking into account the previous path \cite{holler2020htn}. For loop detection PANDA offers hashing based mechanisms both with and without a fallback to full search node comparison \cite{holler2021loop}. Completeness of the planner varies depending on the chosen configuration. If loop detection is configured to allow for false positives, we expect PANDA to not be complete regardless of search algorithm, as there is no mechanism in place to mitigate their effect. If a loop detection mechanism is chosen which does not have false positives, we expect PANDA to be complete if weighted A* with a weight $w > 0$ is used, as this introduces a BFS-like behavior into the search. This leaves pure heuristic DFS combined with loop detection without false positives. Due to the complex nature of the PANDA heuristic we were unable to construct any pathological case which leads PANDA into an infinite recursion. As heuristics are inherently limited we do assume that such cases exist. We will explore this case and the similar case in CrowdHTN in the following paragraph.

\begin{comment}
-algorithm:
- in A* configuration: has a BFS like characteristic giving us completeness
- in heuristic search configuration: we assume that there exist pathological cases similar to CrowdHTN
- loop detection:
- based on hash only: we loose parts of the search space, no completeness
- hash and comparison fallback: no false positives, this is nice
- the open question: where does PANDA fall if we use heuristic search and loop detection without false positives?

similar to CrowdHTN with our new heuristic. As a result, we expect there to be instances which are impossible to solve. However, PANDA also contains a number of loop detection mechanisms described in \cite{holler2021loop} which in some configurations does not have false positives.
\todo{Something like, we'll discuss the implications in the next paragraph}
\end{comment}

\paragraph{Loop detection and completeness}
\label{improv: loops and completeness}
As we have seen, heuristic search on its own may increase planner performance but comes at the cost of completeness. Random DFS is able to find any plan but may still get stuck in endless loops. We will now explore the implications of combining heuristic search with loop detection but without restarts to see how this changes the overall situation. In this paragraph we are only interested in loop detection mechanisms that do not suffer from false positives as, without restarts, this automatically disqualifies a planner from being complete.\\
In general, loops are only a problem in hierarchical planning if there exists at least one recursive task. If no such task exists, there exist only a finite and usually small number of possible task network expansions such that we can easily search the full search space. If we do have a recursive task, we can further classify our instances according to how hard it is to deal with. We identify three categories:
\begin{itemize}
	\item Tasks which recurse into themselves with no change in the world state
	\item Tasks which recurse into themselves with changes in the world state
	\item Tasks which recurse into themselves while adding more tasks afterwards
\end{itemize}
For general HTN planning, a task recursing into itself also implies that the ordering constraints of the new open tasks are a superset of the old ordering constraints. \\
The first case is the easiest to detect and fix. If a task recurses into only itself we do not get any changes to the open tasks. As a result, search nodes before and after this recursion are equivalent. They will be detected by loop detection as it is used in PANDA and CrowdHTN and the search will be guided into another direction. \\
In the second case we have to perform additional work before a loop can be detected. As the set of open tasks stays the same and the world state changes, we do not immediately get equivalent search nodes. However, in an HTN instance with predicates $\mathcal{Q}$, there are only $2^{|\mathcal{Q}|}$ possible world states. We can easily see that we will recurse at most $2^{|\mathcal{Q}|}$ times before our loop detection activates and we backtrack. In practice we can often obtain a smaller upper bound on the possible number of recursions by looking only at the predicates which occur as effects in the resolution of any tasks present in the recursion. We see that, while less efficient, our known loop detection mechanisms correctly deal with this case. \\
This leaves us with the third case, where a task does not directly recurse into itself but where the resolution of task $t$ gives rise to a new instance of $t$ as well as additional tasks $t_1, \ldots, t_k$ which are restricted to be resolved after $t$. As a result, once we re-encounter $t$ our open task set has changed. While we were able to limit the number of possible world states in previous case, this is not possible here, as the number of open tasks is unbounded. More specifically, loop detection as used in PANDA and CrowdHTN is unable to handle this case. \\
Figure \ref{figure: pathological heuristic loop} provides an example of an instance which would guide our proposed heuristic into a recursion while not creating loops. Our heuristic would assign the values 1 to $m_1$, 2 to $m_2$ and 3 to $m_3$. If the preconditions for $m_1$ are not fulfilled we would then apply $m_2$, creating a unique set of open tasks and then repeat application of $m_2$ indefinitely.
% Figure \ref{figure: pathological heuristic loop} provides an example of an instance which would guide our proposed CrowdHTN heuristic into the recursion while not creating loops, as each recursion changes the open tasks by extending the sequence. As mentioned in the previous paragraph, we assume that similar cases can be constructed for other (TO)HTN heuristics.
\begin{figure}
	\caption{Pathological instance for our proposed heuristic that is not caught by loop detection}
	\label{figure: pathological heuristic loop}
	\centering
	\includegraphics[width=0.3\textwidth]{images/prelim/loop_detection_pathological}
\end{figure}

\paragraph{Restarts and completeness}
Together with AMQ based loop detection, we introduced a restart mechanism in \ref{improv: loops and completeness}. We will now go over the use of restarts to achieve completeness for random DFS. \\
To show that restarts help us to achieve completeness for random DFS we can use a similar argument as we did for the loop detection. For any path in our search graph, random DFS gives us a probability $p > 0$ to take this path. As the number of restarts we perform goes to infinity, the probability to take any fixed path at least once goes to 1. We are under the same constraints as previously, needing both an unbounded number of restarts and an unbounded number of runs of at least length $u$ for any $u$. The second constraint is needed so that we do have the time to fully explore a path once we take it. Our restart mechanism fulfills both constraints, restarting with probability $\frac{1}{t}$ at second $t$. It follows that random DFS with restarts is complete.
\begin{comment}
- restarts solve the problem for DFS
- but only if we get some additional properties!
- i.e. we expect an infinite number of restarts
- additionally, we get an infinite number of runs longer than $t$ seconds for any $t$

- this is nice and gives completeness (yay!)

- loop detection also helps
- loop detection specifically helps if the wrong path is recursive
- warning: recursive does not just mean that we resolve to the same task
- two cases:
- resolve to same task, but world state is changing
- i.e., we get the exact same open tasks
- or in case of HTN we get the same open tasks and a subset of possible orderings to what we had before
- this will not immediately be detected
- however, the number of possible world states is bound
- so eventually we will find the loop, but it will take time
- resolve to the same task but also add more tasks afterwards ()
- now the open tasks are different and it is not the same search node anymore
- oh, look, an example domain
- the number of open tasks is unbounded
- heuristics cannot be saved via loop detection
- show an example domain with problems! (i.e. search nodes are not identical if we introduce additional open tasks)


- previous section \ref{improv: search completeness} talked about the completeness of different search paradigms

- Lilotane is complete (BFS-like)
- BFS search is complete
- A-star like search is complete

- we could always achieve trivial completeness, but it is not interesting from a practical perspective

- DFS and heuristic search are problematic
- DFS always has a chance to find the right path, but we have to actually hit it
- heuristic search may deterministically take the wrong way
\end{comment}

\paragraph{Conclusion}
In this section we have taken a look at completeness in hierarchical planners and how loop detection and restarts can help us to achieve it. We have shown that completeness is highly dependent on the specific search behavior with BFS-like behavior being trivially complete. In addition we show that loop detection, while helpful, is not able to solve the problem for some instances. Introducing our restart mechanism, we show that it can turn random DFS into a complete algorithm. This does not extend to heuristic DFS if the heuristic exhibits pathological behavior as the heuristic will always guide the search back into the same recursion.

\begin{comment}
- completeness is highly dependent on algorithm
- recursion remains a major challenge
- not only for runtime
- loop detection can fix many of the problems but not all
- instead of only detecting loops we may have to get better at detecting dead ends
- we may want to randomize our heuristics
- keep the benefits
\end{comment}

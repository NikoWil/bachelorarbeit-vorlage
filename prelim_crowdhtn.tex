\subsection{The CrowdHTN Planner}
\label{prelim: crowdhtn}
The CrowdHTN (\textbf{C}ooperative \textbf{r}andomized \textbf{w}ork stealing for \textbf{D}istributed \textbf{HTN}) planner was introduced in our previous work on parallel and distributed TOHTN planning \cite{bretl2021parallel}. It is implemented as a parallel state machine that uses work stealing for load balancing. According to the definition of \cite{feitelson1997job} we introduced in section \ref{prelim: malleability}, CrowdHTN is a moldable program, as the number of workers is arbitrary but fixed during execution. \\
Each local worker of CrowdHTN owns it's own queue of search nodes and performs progression search on these nodes as explained in \ref{prelim: techniques search}. Search nodes are enhanced with information about the reductions that were applied to reach them, allowing for plan reconstruction once a goal has been found. The basic CrowdHTN parallel search algorithm is shown in algorithm \ref{crowd: parallel algo}. \\
In the initial state, only the root worker has any search nodes. All other workers start empty. To perform load balancing, randomized work stealing is used. The work package exchange is implemented as a three step protocol
\begin{enumerate}
	\item work request
	\item response
	\item ack (if response was positive)
\end{enumerate}
Upon sending a positive work response, a worker increments it's local tracker of outgoing work packages. When receiving an ack, the local tracker of outgoing work packages is decremented. This ensures that there is always at least one node that acknowledges the existence of each search node. This is used to enable CrowdHTN to determine a global UNPLAN. To do this each worker reports whether it has any work left. A worker reports true if it has a non-empty fringe or at least one outgoing work package. \\
This capability is especially helpful for small instances where it is plausible to explore the whole search space. As we saw in the earlier section on complexity (\ref{prelim: tohtn complexity}), TOHTN planning is in D-EXPTIME making it infeasible to explore the whole search space for all but small instances.\\
To extract a work package, a CrowdHTN worker always takes the search node at the back end of the queue and not the end at which the active search is performed. This serves as a heuristic to send off a work package that is as large as possible. Nodes at the back end will be higher up in the hierarchy with more left to explore. Additionally, this reduces overall communication volume, as nodes close to the initial search node will have fewer open tasks and a shorter sequence of preceding reductions, reducing their memory footprint.
\begin{algorithm}
	\caption{The parallel CrowdHTN algorithm}
	\label{crowd: parallel algo}
	\While{true}{
		work\_step()\;
		
		\If{fringe.empty and not has\_active\_work\_request}{
			r $\gets$ random worker id\;
			send work request(r)\;
			has\_active\_work\_request $\gets$ true\;
		}
		
		\For{(message, source) $\in$ incoming messages}{
			\If{message is work request}{
				\eIf{fringe.has\_work()}{
					send positive work response(fringe.get\_work(), source)\;
					outgoing work messages += 1\;
				} {
					send negative work response(source)\;
				}
			}
			
			\If{message is work response}{		
				\If{response is positive}{
					fringe.add(work response)\;
					send work ack(source)\;
				}
				has\_active\_work\_request $\gets$ false\;
			}
			
			\If{message is work ack}{
				outgoing work messages -= 1\;
			}
			
		}	
	}
\end{algorithm}

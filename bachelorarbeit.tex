% Vorlage für eine Bachelorarbeit - 2012-2013 Timo Bingmann

% Dies ist nur eine Vorlage. Strikte Vorgaben wie die Bachelorarbeit auszusehen
% hat gibt es nicht. Darum können auch alle Teile angepasst werden.

% TODO: change away from the enabledeprecatedfontcommands
\documentclass[enabledeprecatedfontcommands,12pt,a4paper,twoside]{scrartcl}

% Diese (und weitere) Eingabedateien sind in UTF-8
\usepackage[utf8]{inputenc}

% Verwende gute Type 1 Font: Latin Modern
\usepackage[T1]{fontenc}
\usepackage{lmodern}

% Sprache des Dokuments (für Silbentrennung und mehr)
\usepackage[german,english]{babel}

% Seitengröße - verwende fast die ganze A4 Seite
\usepackage[tmargin=22mm,bmargin=22mm,lmargin=20mm,rmargin=20mm]{geometry}

% Einrückung und Abstand zwischen Paragraphen
\setlength\parskip{\smallskipamount}
\setlength\parindent{0pt}

% Einige Standard-Mathematik Pakete
\usepackage{latexsym,amsmath,amssymb,mathtools,textcomp}

% Unterstützung für Sätze und Definitionen
\usepackage{amsthm}

\newtheorem{Satz}{Satz}[section]
\newtheorem{Definition}[Satz]{Definition}
\newtheorem{Lemma}[Satz]{Lemma}

\numberwithin{equation}{section}

% Deutsches Literaturverzeichnis
\usepackage{bibgerm}

% Unterstützung zum Einbinden von Graphiken
\usepackage{graphicx}

% Pakete die tabular und array verbessern
\usepackage{array,multirow}

% Kleiner enumerate und itemize Umgebungen
\usepackage{enumitem}

\setlist[enumerate]{topsep=0pt}
\setlist[itemize]{topsep=0pt}
\setlist[description]{font=\normalfont,topsep=0pt}

\setlist[enumerate,1]{label=(\roman*)}

% TikZ für Graphiken in LaTeX
\usepackage{tikz}
\usetikzlibrary{calc}

% Aktuelle Section und Untersection am Seitenkopf
\usepackage{fancyhdr}

\fancypagestyle{plain}{
  \fancyhead{}
  \fancyfoot{}
  \fancyfoot[LE,RO]{\normalsize\thepage}
  \renewcommand{\headrulewidth}{0pt}
  \renewcommand{\footrulewidth}{0pt}
}

\fancypagestyle{normal}{
  \setlength{\headheight}{20pt}
  \setlength\footskip{32pt}
  \fancyhead{}
  \fancyhead[LE]{\normalsize\textsc{\nouppercase{\leftmark}}}
  \fancyhead[RO]{\normalsize\textsc{\nouppercase{\rightmark}}}
  \fancyfoot{}
  \fancyfoot[LE,RO]{\normalsize\thepage}
  \renewcommand{\headrulewidth}{0.4pt}
  \renewcommand{\footrulewidth}{0pt}
}

% Hyperref für Hyperlink und Sprungtexte
\usepackage{xcolor,hyperref}

\hypersetup{
  pdftitle={Malleable Distributed Hierarchical Planning},
  pdfauthor={Niko Wilhelm},
  pdfsubject={Stichworte, weiteres Stichwort},
  colorlinks=true,
  pdfborder={0 0 0},
  bookmarksopen=true,
  bookmarksopenlevel=1,
  bookmarksnumbered=true,
  linkcolor=blue!60!black,
  %linkcolor=black,
  citecolor=blue!60!black,
  urlcolor=blue!60!black,
  filecolor=green!60!black,
  pdfpagemode=UseNone,
  unicode=true,
}

% Paket zum Setzen von Algorithmen in Pseudocode mit kleinen Stilanpassungen
\usepackage[ruled,vlined,linesnumbered,norelsize]{algorithm2e}
\DontPrintSemicolon
\def\NlSty#1{\textnormal{\fontsize{8}{10}\selectfont{}#1}}
\SetKwSty{texttt}
\SetCommentSty{emph}
\def\listalgorithmcfname{List of Algorithms}
\def\algorithmautorefname{Algorithmus}
\let\chapter=\section % repariert ein Problem mit algorithm2e

\DeclareOldFontCommand{\bf}{\normalfont\bfseries}{\mathbf}

\usepackage{todonotes}
\usepackage{comment}
\usepackage{algorithm2e}
\usepackage{adjustbox}
\usepackage{subcaption}

\newtheorem{definition}{Definition}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{empty} % keine Seitenzahlen

% Titelblatt der Arbeit
\begin{titlepage}

  \begin{center}\large

    \quad\includegraphics[height=17mm]{kit_logo_de.pdf} \hfill
    \includegraphics[height=20mm]{grouplogo-algo-blue.pdf}\quad\null

    \vfill

    Master's Thesis
    \vspace*{2cm}

    {\bf\huge Malleable Distributed Hierarchical Planning \par}
    % Siehe auch oben die Felder pdftitle={}
    % mit \par am Ende stimmt der Zeilenabstand

    \vfill

    Niko Wilhelm

    \vspace*{15mm}

    Date of submission: \today

    \vspace*{45mm}

    \begin{tabular}{rl}
      Betreuer: & Prof. Dr. Peter Sanders \\
      & M.Sc. Dominik Schreiber \\
    \end{tabular}
    
    \vspace*{10mm}

    Institut für Theoretische Informatik, Algorithmik \\
    Fakultät für Informatik \\
    Karlsruher Institut für Technologie

    % English:
    % Institute of Theoretical Informatics, Algorithmics \\
    % Department of Informatics \\
    % Karlsruhe Institute of Technology

    \vspace*{12mm}
  \end{center}

\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\vspace*{0pt}\vfill

\hrule\medskip

Hiermit versichere ich, dass ich diese Arbeit selbständig verfasst und keine anderen, als die angegebenen Quellen und Hilfsmittel benutzt, die wörtlich oder inhaltlich übernommenen Stellen als solche kenntlich gemacht und die Satzung des Karlsruher Instituts für Technologie zur Sicherung guter wissenschaftlicher Praxis in der jeweils gültigen Fassung beachtet habe.

\bigskip

\noindent
Karlsruhe, den \today

% Unterschrift (handgeschrieben)

\vspace*{5cm}

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\vspace*{0pt}\vfill

\selectlanguage{german}
\begin{abstract}
\centerline{\bf Zusammenfassung}

Totally Ordered Hierarchical Task Network (TOHTN) planning ist ein Teilgebiet der künstlichen Intelligenz und gehört zum weiteren Bereich des domänenunabhängigen Planens. Beim TOHTN planning werden offene Tasks rekursiv aufgelöst und verfeinert bis wir einen ausführbaren Plan aus primitiven Aktionen erhalten. TOHTN planning ist von hoher Komplexität gekennzeichnet und gehört zur Klasse der Probleme in D-EXPTIME und ist EXPSPACE-hart. \\
Malleability bezeichnet die Fähigkeit eines Programms, zur mit einer sich verändernden Menge verfügbarer Ressourcen zurecht zu kommen. Sie erlaubt den effizienten Einsatz von Ressourcen, da sie erlaubt Ressourcen zu jedem Zeitpunkt vollständig zu nutzen anstatt einen Kompromiss aus Durchsatz und Latenz anstreben zu müssen. Programme zu schreiben die dies erfüllen ist jedoch eine Herausforderung, weswegen es nur wenige Beispiele gibt. \\
Um die Möglichkeiten des parallelen Planens auszuloten und zudem die Möglichkeiten des Load Balancers und Schedulers Mallob aufzuzeigen haben wir unseren parallelen Planner CrowdHTN in Mallob integriert. Zudem haben wir die Performance von CrowdHTN mithilfe eines verteilten Schemas zur Schleifenerkennung basierend auf Bloom Filtern verbessert und Neustarts genutzt, um die Vollständigkeit unseres Algorithmus' zu garantieren. \\
In unserer Evaluation zeigen wir, dass sowohl die verteilte Schleifenerkennung als auch die Neustarts die Performanz und die Menge gelöster Instanzen erhöhen. Zudem zeigen wir, dass wir auch in einem veränderlichen Umfeld die Fähigkeit beibehalten, Instanzen zu lösen.

\end{abstract}

\vfill

\selectlanguage{english}
\begin{abstract}
\centerline{\bf Abstract}
Totally Ordered Hierarchical Task Network (TOHTN) planning is a sub-field of artificial intelligence and belongs to the area of domain-independent planning. In TOHTN planning we recursively resolve open tasks, refining them, until we obtain an executable plan consisting of primitive actions. TOHTN planning is computationally and it belongs to the class of D-EXPTIME while being EXPSPACE-hard. \\
Malleability is the ability of a program to handle a changing amount of assigned resources at run time. It allows for a more efficient use of resources as it frees schedulers to utilize all resources at all times instead of finding a compromise between throughput and latency. At the same time, it is a challenge to implementers and few malleable programs exist. \\
To further explore parallel TOHTN planning and to demonstrate the capabilities of malleable scheduler and load balancer Mallob we perform an integration of our parallel planner CrowdHTN with the aforementioned Mallob. Additionally, to increase the performance of CrowdHTN, we introduce a new distributed loop detection scheme based on bloom filters and utilizing restarts for correctness. \\
In our evaluation we find that both distributed loop detection and restarts positively impact performance and coverage of our planner while showing that we retain the capability to solve problems in a malleable environment. \\

\end{abstract}
%\selectlanguage{english}

\vfill\vfill\vfill
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\vspace*{0pt}\vfill

%\section*{Danksagungen}
%\todo{Finish!}
%Thanks to my advisor, Dominik Schreiber
%- ready to help me 
%- the many facilities of Mallob 
%Additional thanks to my friends and flatmates who helped keep me grounded during this work.
%Thanks to i10pc135 which suffered much to make the experimental evaluation possible.

%\vfill\vfill\vfill
%\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{normal}
% markiere sections im Seitenkopf links und subsections rechts
\renewcommand\sectionmark[1]{\markboth{\thesection\quad\MakeUppercase{#1}}{\thesection\quad\MakeUppercase{#1}}}
\renewcommand\subsectionmark[1]{\markright{\thesubsection\quad\MakeUppercase{#1}}}

% Inhaltsverzeichnis
\tableofcontents

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\listoffigures
\listoftables
\listofalgorithms

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
Planning via Hierarchical Task Networks (HTN) is a popular approach to automated AI planning. HTN planning works by repeatedly decomposing a set of initial tasks until they have been decomposed to the level of simple actions \cite{georgievski2015htn, bercher2019survey}. These actions form a plan which can be executed to achieve the goal set out by the initial tasks. Totally Ordered (TO) HTN planning is an important sub-problem of HTN planning where all tasks are constrained by a total order. \\
Hierarchical planners are easy to use as the hierarchy allows the user to insert a structure into the problem description and to provide the planner with advice to guide the planning procedure. As a result, HTN planning has been used in a number of fields. \cite{munoz2004role} have used HTN planning for AI in real-time strategy games. Similarly, \cite{ontanon2015adversarial} have improved their minimax game tree search in real-time strategy games via HTN, which allowed them to reduce the branching factor of their problem. This approach was further extended by \cite{lin2020htn} to also take the opponent's strategy into account. Further applications of HTN planning include automated web service composition \cite{sirin2004htn} as well as the composition of cloud applications \cite{georgievski2017cloud}, socially assistive robotics \cite{gonzalez2017three}, storyline visualizations \cite{padia2018yarn} and automated machine learning \cite{mohr2018ml}. \\
While popular with users, HTN planning does present challenges for implementers as instances can be very CPU and memory intensive to solve. It was shown that HTN planning itself is only semi-decidable and that TOHTN planning is still in D-EXPTIME while being EXPSPACE-hard \cite{erol1994htn, erol1996complexity}. Regarding the expressive power of TOHTN problems they correspond to the class of context-free languages \cite{holler2014language}. Part of the complexity in HTN planning stems from its recursive nature. As a result of this, the detection of duplicate states plays an important role in the performance of planners \cite{holler2021loop}. \\
\begin{comment}
- hierarchical planning is popular
- domain-independent automated planning
- decompose a set of initial tasks until they have been decomposed to the level of simple actions
- these actions form a plan which achieve the initial tasks
- TOHTN planning is a sub-problem of HTN planning where all tasks are constrained by a total order

- hierarchical planners are easy to use
- hierarchy allows the user to insert structure into the problem and advise the planner
- hierarchical planning is used in a number of domains
- \cite{munoz2004role} real-time strategy games\\
- \cite{ontanon2015adversarial} improve minimax game tree search in RTS, reduce branching factor
- \cite{lin2020htn} also takes the opponent's strategy into account

- \cite{sirin2004htn} web service composition
- \cite{georgievski2017cloud} cloud application composition

- \cite{gonzalez2017three} socially assistive robotics
- \cite{padia2018yarn} storyline visualizations
- \cite{mohr2018ml} automated machine learning

- hierarchical planning is expensive \cite{erol1994htn}
- HTN is semi-decidable, TOHTN is in D-EXPTIME, EXPSPACE-hard \cite{erol1996complexity}
- there is a correspondence between TOHTN and context free languages \cite{holler2014language}
- hierarchical problems can be recursive which makes the detection of duplicate states important
\end{comment}

Malleability is the ability of a parallel job to efficiently integrate new PEs into a parallel job at run time as well as handle a reduction of the available PEs \cite{feitelson1997job}. Malleable programs are well-liked by administrators of supercomputers, as they allow the utilization of all compute resources, maintaining both high throughput and keeping latencies for new jobs low \cite{feitelson1997job, hungershofer2004combined}. The malleable model does pose additional challenges for application programmers, though and malleable jobs are only easy to implement if we restrict our problems to those which split into small, independent work packages \cite{feitelson1997job, tucker1989process} and few malleable applications exist. 
However, in recent years a number of malleable SAT solvers have emerged. Among those Mallob \cite{sanders2022decentralized} and Paracooba \cite{heisinger2020distributed}. This is of special importance as SAT solvers serve as a building block in many other applications such as hierarchical planning. Having malleable SAT solvers available may allow for other applications to profit from this paradigm while being presented a simple to use interface. \\

In this thesis, we present three main advances in parallel and malleable TOHTN planning. \\
Firstly, we present a number of improvements for the parallel search-based planner CrowdHTN.
Both HyperTensioN \cite{magnaguagno2020hypertension} and PANDA \cite{holler2021loop} have shown the importance of detecting duplicate search nodes to improve the performance of hierarchical planners. PANDA specifically uses an approach based on hashing which may fall back to full node comparisons to avoid false positives. Parallel planner CrowdHTN already includes a loop detection mechanism based on the ideas of PANDA \cite{bretl2021parallel}. We take the idea of PANDA to only compare hashes and not full nodes and generalize it to bloom filters which may use any number $k$ of hash functions to reduce false positive rates. Bloom filters then allow us to present a design for a distributed loop detection mechanism. Additionally, PANDA has shown that heuristics can greatly increase the performance of search-based planner \cite{holler2020htn}. We try to adapt heuristic search for CrowdHTN while under the added constraints of malleability. Doing so, we implement BFS, heuristic DFS and A-star in CrowdHTN.
Last, we take inspiration from SAT where restarts have been used since the 90's \cite{crawford1994experimental} to design a restarting scheme for CrowdHTN which allows it to be complete even as bloom filter based detection of duplicate nodes may lead to false positives. \\
Second, we provide a general overview of the completeness of different TOHTN planning approaches. We show that both search-based planners using BFS, A-star and current SAT-based planners are complete. In addition we argue that heuristic best-first search may always be incomplete and that, while current loop detection mechanisms are helpful for planner performance, there are cases of recursion in hierarchical planning problems which they are unable to detect. Lastly, we show that our restart mechanism brings random DFS into the list of algorithms which are complete on all problems. \\
Third, we present our design of a malleable TOHTN planner. In this we integrate our planner CrowdHTN with the malleable job scheduler Mallob. We offer an overview of our design and show how work stealing in general can be adapted to a malleable framework while preserving completeness of the search. Doing so we also show Mallob's capabilities as a general purpose job scheduler and load balancer.\\
In our evaluation we find that our implementation suffers from some overhead due to the integration into the Mallob scheduler.
However, we also see that bloom filters in general outperform hash sets when it comes to detecting duplicate states in TOHTN planning and that this performance gain extends to our distributed loop detection scheme. We further find that restarts not only serve to ensure the completeness of our planner while using bloom filters but have an additional positive impact on overall performance. Regarding malleability, we see that our proposed malleable work stealing scheme can suffer from some loss of performance when a large number of PEs is frequently reshuffled but that this can be mitigated with frequent restarts. \\

The rest of this work follows the following structure: in section \ref{prelim} we introduce a TOHTN planning formalism as well as planning techniques, followed by an intro to malleability and an overview of parallel and distributed computing techniques that inform the design of CrowdHTN. It ends with a short introduction to CrowdHTN and Mallob. Section \ref{improv} presents us two potential theoretical improvements to CrowdHTN and the design of a distributed loop detection scheme. In section \ref{improv: completeness} we show how current loop detection schemes are unequipped to ensure completeness of hierarchical planners and argue for the use of restarts as an alternative technique. Section \ref{malleable: overview} presents our design of a malleable parallel TOHTN planner based on work stealing. This is followed by section \ref{impl} which contains implementation details of both our improvements and the malleable design. Finally, section \ref{eval} evaluates and compares our planner to it's old standalone version, presents the performance impact of our various improvements and provides an overview of the behavior of CrowdHTN as the number of PEs scales as well as under malleable conditions. Section \ref{conclusion} concludes this work.
	
\clearpage
\pagebreak
\section{Preliminaries}
\label{prelim}
This section we introduce the TOHTN formalism and discuss it's complexity and differences to classical planning in \ref{prelim: formalism}. This is followed by an overview and comparison of TOHTN planning techniques in \ref{prelim: techniques}, and a classification of parallel programs and discussion of malleability in \ref{prelim: malleability}. In \ref{prelim: parallel distributed} we introduce the parallel techniques underlying our planner. We conclude by introducing our parallel planner CrowdHTN in \ref{prelim: crowdhtn} and the malleable load balancer and scheduler Mallob in \ref{prelim: mallob}.
\input{prelim_tohtn_formalism}
\input{prelim_tohtn_techniques}
\input{prelim_malleability}
\input{parallel_distributed}
\input{prelim_crowdhtn}
\input{prelim_mallob}

\clearpage
\pagebreak
\section{Theoretical Improvements of the CrowdHTN Planner}
\label{improv}
In this section we will introduce two improvements to CrowdHTN. First we changed the underlying implementation of our planner, which allows us to easily switch out the search algorithm we use. We introduce them in \ref{improv: search algorithms} and discuss their expected performance characteristics. Afterwards we start a discussion about loop detection in TOHTN planning, the data structures which may help us and how we design our new distributed loop detection scheme in \ref{improv: loop detection}.
\input{improv_search_algorithms}
\input{improv_loop_detection}
\clearpage
\pagebreak
\section{Completeness of HTN Planning Algorithms}
\label{improv: completeness}
\input{improv_planner_completeness}
\clearpage
\pagebreak
\section{A Malleable TOHTN Planner}
\label{malleable: overview}
\input{malleable_tohtn}
\clearpage
\pagebreak
\section{Implementation}
\label{impl}
In this section we will give an overview of the implementation work we performed. We start out with an overview of the integration of CrowdHTN into Mallob in \ref{impl: mallob integration} where we present the Mallob interface, explain how we implemented it while adhering to Mallob's performance guarantees, mention how we improved the reliability of CrowdHTN in low memory conditions and end with a detailed overview of how we handle messages addressed to PEs that no longer belong to the same job. This is followed by our mechanism for efficiently handling restarts in \ref{impl: version increase} and an explanation of how we perform an all-reduction in a malleable environment to allow for global loop detection in \ref{impl: global loop}. We conclude with CrowdHTN's improved algorithm for the expansion of search nodes in \ref{impl: reduce nodes} and our presentation of an efficient way to hash search nodes in \ref{impl: efficient hashing}.
\input{impl_mallob_integration}
\input{impl_crowd_improvements}
\clearpage
\pagebreak
\section{Experimental Evaluation}
\label{eval}
In this section we will perform an evaluation of our new CrowdHTN implementation as it is integrated into Mallob, the new features we added into CrowdHTN and how it behaves in a malleable environment. \\
We start out by presenting our experimental setup in \ref{eval: setup}, including the naming scheme we use to identify different versions and configurations of CrowdHTN. After, we first offer an overview of the performance of CrowdHTN as a standalone program and improved CrowdHTN integrated into Mallob.
This is followed by more detailed discussions of the different improvements and features we added. We will review the effect of the improvements on the implementation level and discuss the behavior of different search algorithms in CrowdHTN. Then we see how the performance changes as we enable bloom filters for loop detection, probabilistic restarts and distributed loop detection one after the other. We conclude with a discussion on the scaling behavior and the performance of CrowdHTN in a malleable environment, followed by an overall recap. \\
The overall results can also be seen in tables \ref{table: results old} for the sequential planners and standalone CrowdHTN and \ref{table: results new} for CrowdHTN integrated into Mallob.
\input{eval}
\clearpage
\pagebreak
\section{Conclusion}
\label{conclusion}
In this work, we have investigated and improved methods of parallel TOHTN planning and designed a malleable TOHTN planner based on work stealing. We will summarize our work in \ref{recap} and provide a short outlook in \ref{future work}.

\subsection{Recap}
\label{recap}
In hierarchical planning we repeatedly decompose a set of initial tasks until we have obtained a sequence of actions we can directly apply to achieve our initial goal. Malleability is the ability of a program to handle a varying amount of available resources during execution. We set out to improve the performance and scalability of our parallel planner CrowdHTN by experimenting with different search algorithms and designing a distributed loop detection scheme.
In addition to this, we showed that current loop detection schemes are insufficient to guarantee completeness for our planner and argue for restarts to ensure correctness.
To adapt our parallel planner into a malleable environment, we present our design of CrowdHTN integrated into the malleable scheduler and load balancer Mallob. \\

We evaluate our improved planner on a subset of the benchmark used in the IPC 2020. There we find that both bloom filters and distributed loop detection improve the overall performance and see that our planner shows clear scaling. In addition, we find that our restart scheme has positive performance implications beyond guaranteeing completeness. \\
While our planner guarantees completeness and work stealing makes it easy to efficiently use new PEs in a malleable environment, we see performance degradation due to information loss when a large number of available PEs is frequently reshuffled. \\

Overall, scalable and performant TOHTN planning seems possible but will need more work to improve the search itself as the high branching factor of TOHTN problems limits the potential of a brute force approach as used in CrowdHTN. Similarly, malleable applications based on work stealing in general and malleable TOHTN planning specifically seem worthwhile as the problems with information loss get addressed.

\input{future_work}

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{gerplain}
\bibliography{literatur}

\end{document}

\subsection{Techniques to solve HTN planning problems}
\label{prelim: techniques}
In this section, we will give an overview over the different techniques with which HTN problems can be solved. The HTN planners produced by researchers can be classified along two main axes:
\begin{itemize}
	\item the planning algorithm
	\item lifted vs grounded approaches
\end{itemize}
For the algorithms, the two main variations are translation-based algorithms that take an HTN instance and translate it into a problem in a simpler complexity class such as classical planning or propositional logic (SAT) and search-based algorithms that utilize techniques such as plan-space search and progression search. We will focus on progression search here, as it is the technique employed in our own planner, CrowdHTN. \\
After that we will have a short discussion on lifted versus grounded approaches which is largely independent of the search algorithm.
\begin{comment}
- multiple ways to solve HTN instances
- planners can be classified on two axis: the algorithm and lifted vs grounded
- in practise, most algorithms are based on translation to SAT or on search algorithms
- we will focus on search-based as we will see in later section \ref{prelim: crowdhtn} that this is what our own planner utilizes
\end{comment}

\subsubsection{Translation-based}
\label{prelim: translation based planners}
One of the main techniques employed in HTN planning is to find an efficient encoding into a simpler problem. Two such problems are classical planning \cite{alford2016bound} and SAT. While translation to SAT was already proposed in 1998 \cite{mali1998encoding}, the first complete encoding without assumptions about the instance was publicized in 2018 \cite{behnke2018totsat}. In recent years, SAT seems to be the most popular problem to translate an HTN instance into, utilized by planners such as totSAT \cite{behnke2018totsat, behnke2018tracking}, Tree-REX \cite{schreiber2019tree} and Lilotane \cite{schreiber2021lilotane}. \\
As we have seen in the previous section \ref{prelim: tohtn complexity} on (TO)HTN complexity, (TO)HTN problems are in D-EXPTIME and undecidable respectively. Both classical planning and SAT are less powerful. As a result, HTN problems cannot be encoded and even for TOHTN problems we would suffer a blowup in the size of the instance. Instead, as noted in \cite{schreiber2019tree}, SAT-based planners tend to explore subproblems by encoding the set of potential hierarchies layer by layer, increasing the encoding size as they go. As a result, those SAT-based planners tend to have a BFS-like characteristic to their search.

\begin{comment}
- may translate to classical planning \cite{alford2016bound}
- SAT-based has been known since 1998 \cite{mali1998encoding}
- tend to explore the hierarchy layer-by-layer \cite{schreiber2019tree}
- this gives the search a BFS-like characteristic
- this is needed, as SAT is NP-complete compared to HTN which is undecidable and TOHTN which is in D-EXPTIME \ref{prelim: tohtn complexity}
- encoding the whole instance would be impossible in case of HTN and lead to blowup in instance size in case of TOHTN
- going bit by bit is done instead

- example planners are Tree-REX \cite{schreiber2019tree}, totSAT \cite{behnke2018totsat}, Lilotane \cite{schreiber2021lilotane}
\end{comment}

\subsubsection{Search-based}
\label{prelim: techniques search}
The second main category of techniques to solve HTN planning problems are search-based algorithms, such as plan space search and progression search. \\
Plan space search searches the space of partial plans, where search nodes represent partial plans and edges represent plan refinements \cite{weld1994introduction}. \\
As progression search is both more prominent in current planners and our own planner, CrowdHTN, also utilizes it we will now focus on this paradigm according to \cite{holler2020htn}.
Progression search generates plans in a forward way. Search nodes are represented as tuples $(tn, s)$ of open tasks $tn$ and world state $s$. It always chooses an open task that is currently unconstrained, i.e. has no unresolved predecessors under the ordering constraints, and resolves it. This allows the planner to update the world state as it goes along, as the sequence of actions from the start to the current point is known at each step of the search. In case of TOHTN planning, the choice of the next unconstrained task becomes trivial, as there is always exactly one such task. Knowing the full world state gives progression search two main advantages over plan space search. First, it allows the planner to prune parts of the search space by immediately validating action and reduction preconditions against this world state. Second, it gives us maximum information to be used in heuristics that guide our search. \\
The progression search algorithm is given in pseudocode in algorithm \ref{algo: progression search}. As mentioned, line 6 becomes trivial for TOHTN planning and the loop from lines 7  to 16 is no loop, as there is always exactly one unconstrained task. Additionally, the location of our goal test can be moved around, depending on need. Performing the goal test upon popping a node is useful if we want to find optimal plans and our fringe data structure - and thus popping order - have a notion of node cost. Performing the goal test upon node creation allows us to terminate earlier. \\
Notable search-based planners are SHOP (\cite{nau1999shop}), HyperTensioN (\cite{magnaguagno2020hypertension}), PANDA (\cite{holler2020htn}) and our own planner CrowdHTN which will be presented in a later section \ref{prelim: crowdhtn}.
\begin{comment}
\cite{holler2020htn}
- progression search is one of the best known search algorithms
- generate plans in a forward way
- always resolve a task that has no more open predecessors with the ordering constraints (is called 'unconstrained task')
- own: for TOHTN: we always have exactly 1 task we want to process next!
- makes it trivial to find the next unconstrained task
- mentioned in the paper
- progression search planners always know the current (world) state, can use this information for heuristics, pruning etc

- other planners search partial plans but not in order, they thus cannot know the current world state
- perform goal test on popping: find optimal plan if popping order is informed by cost
- perform goal test before popping: explore fewer nodes

- Alford et al, 2012, Thm. 3 -> HTN problem is solvable <=> there is a solution in progression space

- parts of the search space will be searched more than once if no additional measures are taken
\end{comment}
\begin{algorithm}
	\caption{Classical Progression Search for HTN as introduced in \cite{holler2020htn}}
	\label{algo: progression search}
	$fringe \gets \{ (s_0, tn_I, \epsilon)\}$\;
	\While{$fringe \neq \emptyset$}{
		$n \gets fringe.pop()$\;
		\If{$n.isgoal$}{
			\textbf{return} $n$\;
		}
		$U \gets n.unconstrainedNodes$\;
		\For{$t \in U$}{
			\eIf{$isPrimitive(t)$}{
				\If{$isApplicable(t)$}{
					$n' \gets n.apply(t)$\;
					$fringe.add(n')$\;
				}
			}{
				\For{$m \in t.methods$}{
					$n' \gets n.decompose(t, m)$\;
					$fringe.add(n')$\;
				}
			}
		}
	}
\end{algorithm}

\subsubsection{Lifted and Ground HTN Planning}
As mentioned in section \ref{prelim: tohtn problems}, HTN instances are normally given in a lifted representation and can be ground, i.e. all variables are filled with all possible parameter combinations. Specifying the instance in a lifted fashion is done for ease of use, as it is a more compact representation and allows domains to be reused for different problems \cite{behnke2020succinct}. \\
The efficient grounding and pruning of HTN instances is an active field of research \cite{ramoul2017grounding, behnke2020succinct}. While it is an easier problem than HTN planning itself, it can take exponential time and the ground instance may be exponential in size compared to the lifted instance \cite{behnke2020succinct}. \\
Planners may choose to operate on either lifted or ground instances. A discussion on the trade-offs involved is found in \cite{schreiber2021lilotane}. We will reiterate the main advantage of each approach here. Grounded representations have more information available for pruning. As an example, while some parameter combinations in reductions may lead to a contradiction later on and can thus be pruned, not all such combinations may be invalid and thus the corresponding lifted method may not be prunable. Lifted representations on the other hand may be a lot more compact in practice. For example, our TOHTN instance may want us to choose any of $N$ trucks to transport a package from $A$ to $B$ where in practice the choice might not matter. Whereas a grounded representation will have to instantiate all operators concerning a truck $N$ times, a lifted operation will avoid this and only choose a truck ad-hoc. \\
The choice of grounded vs lifted representation is independent of the choice of planning algorithm. We have examples of grounded translation-based planners (totSat \cite{behnke2018totsat}, Tree-REX \cite{schreiber2019tree}), lifted translation-based planners (Lilotane \cite{schreiber2021lilotane}) and also search-based planners that work on both lifted (HyperTensioN \cite{magnaguagno2020hypertension}) and ground representations (PANDA \cite{holler2020htn}). \\
Our own planner, CrowdHTN, walks a middle ground. It performs its search on a ground representation to allow detailed run time pruning according to the world state. However, it does not front-load the cost of a grounding procedure and instead grounds tasks and methods as needed.
\begin{comment}
- grounding can be an expensive operation \cite{behnke2020succinct}
- grounding is an active field of research within hierarchical planning \cite{ramoul2017grounding}, \cite{behnke2020succinct}
- a discussion on the benefits and trade-offs of grounding is available in \cite{schreiber2021lilotane}
- grounded representations can have more information available for subsequent pruning, i.e. only a certain parameter combination for a reduction may be invalid but not a whole method
- lifted representations can be a lot more compact 

- efficient grounding is its own research area \cite{behnke2020succinct} \todo{cite the other comparison papers from behnke's work}


- lifted vs grounded
- Lilotane, HyperTensioN
- Panda, CrowdHTN, Tree-Rex
- lifted: more general, less pruning?
\end{comment}

\subsubsection{Comparing the Techniques}
Current SAT-based planners tend to explore the space of potential task networks in a layer-by-layer fashion, lending a BFS-like characteristic to their search. Progression search on the other hand is often implemented as DFS which may be further guided by heuristics. In the International Planning Competition (IPC) 2020, we saw a demonstration of these different characteristics \cite{behnke2020ipcresults}. HyperTensioN, the overall winner, is a search based planner. Its performance is hit-or-miss, i.e., plans are either found extremely quick or not at all. On four out of 24 domains HyperTensioN failed to find any plan at all. Lilotane, the runner up, is a SAT-based planner. While reaching a lower overall rating, it managed to find plans on a wider selection of domains. \\
Within the IPC, planners were rated with the so-called agile metric. If a plan is found in less than one second, a score of 1 is awarded. If no plan is found within the time limit $T$, then a score of 0 is awarded. For run times $0 < t < T$, the score is set as $1 - \frac{\log{t}}{\log{T}}$. The agile metric focuses on fast run times over the overall number of problems solved. A different metric which can be used is the coverage. Here the run times are ignored and only the overall number of solved problems is measured. According to \cite{schreiber2021lilotane}, Lilotane outperforms HyperTensioN in coverage. In addition, it excels at finding short plans. \\
In our previous research on parallel hierarchical planning we have shown that a portfolio of search-based and SAT-based planners can lead to improved run times and coverage overall, combining the strengths of both approaches \cite{bretl2021parallel}.

\begin{comment}
- progression search in practice is often DFS
- SAT-based to explore layer by layer, similar to BFS
- planner performance shows these characteristics
- results of the IPC 2020 show this \cite{behnke2020ipcresults}
- HyperTensioN is hit-or-miss, four of the 24 domains with no solution at all
- Lilotane, best in class for SAT  and second place found plans on more domains

- according to IPC 2020 HyperTensioN is the best planner
- used the agile metric, score from 1 if solution in less than a second
- 1 - log(t) / log(T) if run time between 1 and T
- 0 otherwise
- T was 30 minutes

- other metric: coverage
- according to \cite{schreiber2021lilotane}, Lilotane has better coverage than HyperTensioN on the IPC 2020 benchmark
- Lilotane is good at finding based at short plans

- loop detection by \cite{holler2021loop} improved progression search
\end{comment}
